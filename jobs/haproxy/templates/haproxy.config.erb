<%- # see https://bosh.io/docs/jobs/#properties for documentation of bosh ERB templates -%>
<%
  def format_indented_multiline_config(raw_config)
    ident = "    "
    if raw_config
      if raw_config.is_a?(Array)
        out = ""
        sep = ""
        raw_config.each do |line|
          out = out + sep+ line
          sep = "\n"+ident
        end
        return out
      else
        raw_config.strip.gsub(/\n/, "\n"+ident)
      end
    end
  end

  if properties.ha_proxy.config_mode == "auto"
    if properties.ha_proxy.raw_config -%>
<%= p("ha_proxy.raw_config") %>
<%- else -%>
<%-
require "digest"
# Ruby Variables to make the template more readable

# Stats Binding Variables {{{
stat = p("ha_proxy.stats_bind").split(':')
stat_prefix = stat[0] + ":"
stat_port = stat[1].to_i
# }}}
# Accept Proxy {{{
accept_proxy = ""
if p("ha_proxy.accept_proxy")
  accept_proxy = "accept-proxy"
end
tcp_accept_proxy = accept_proxy
if p("ha_proxy.disable_tcp_accept_proxy")
  tcp_accept_proxy = ""
end
# }}}
# Global SSL Flags {{{
ssl_flags = ""
use_disable_ssl = true
if_p("ha_proxy.ssl_min_ver") do |ssl_min_ver|
  use_disable_ssl = false
  ssl_flags = "ssl-min-ver #{ssl_min_ver}"
  if_p("ha_proxy.ssl_max_ver") do |ssl_max_ver|
    ssl_flags = "#{ssl_flags} ssl-max-ver #{ssl_max_ver}"
  end
end
if use_disable_ssl
  ssl_flags = "no-sslv3"
  if p("ha_proxy.disable_tls_10")
    ssl_flags = "#{ssl_flags} no-tlsv10"
  end
  if p("ha_proxy.disable_tls_11")
    ssl_flags = "#{ssl_flags} no-tlsv11"
  end
  if p("ha_proxy.disable_tls_12")
    ssl_flags = "#{ssl_flags} no-tlsv12"
  end
  if p("ha_proxy.disable_tls_13")
    ssl_flags = "#{ssl_flags} no-tlsv13"
  end
end
if p("ha_proxy.disable_tls_tickets")
  ssl_flags = "#{ssl_flags} no-tls-tickets"
end
# }}}
# TLS Bind Options {{{
mutual_tls_enabled = p("ha_proxy.client_cert")
ssl_enabled = false
crt_config = ""
if_p("ha_proxy.ssl_pem") do
  ssl_enabled = true
  crt_config="crt /var/vcap/jobs/haproxy/config/ssl"
  if_p("ha_proxy.client_ca_file") do
    mutual_tls_enabled = true
  end
  if_p("ha_proxy.client_revocation_list") do
    mutual_tls_enabled = true
  end
end
if_p("ha_proxy.crt_list") do
  if ssl_enabled
    abort("Conflicting configuration. Please configure either 'ssl_pem' OR 'crt_list', but not both")
  end
  ssl_enabled=true
  crt_config="crt-list /var/vcap/jobs/haproxy/config/ssl/crt-list"
  p("ha_proxy.crt_list").each do |crt_entry|
    if crt_entry.key?("client_ca_file") || crt_entry.key?(" client_revocation_list") || crt_entry["verify"] == "optional" || crt_entry["verify"] == "required"
      mutual_tls_enabled = true
    end
  end
end

client_ca_certs = "/etc/ssl/certs/ca-certificates.crt"
if_p("ha_proxy.client_ca_file") do
  client_ca_certs = "/var/vcap/jobs/haproxy/config/client-ca-certs.pem"
end

strict_sni = ""
if_p("ha_proxy.strict_sni") do |sni|
  if sni
    strict_sni = "strict-sni"
  end
end

tls_options = "#{crt_config} #{strict_sni}"
if mutual_tls_enabled
  tls_options = "#{tls_options} ca-file #{client_ca_certs} verify optional"
  if_p("ha_proxy.client_cert_ignore_err") do |ignore_errs|
    tls_options = "#{tls_options} crt-ignore-err #{ignore_errs}"
    tls_options = "#{tls_options} ca-ignore-err #{ignore_errs}"
  end
  if_p("ha_proxy.client_revocation_list") do
    tls_options = "#{tls_options} crl-file /var/vcap/jobs/haproxy/config/client-revocation-list.pem"
  end
end

tls_bind_options = "ssl #{tls_options}"
# }}}
# X-Forwarded-Client-Cert (XFCC) Option {{{
mtls_header_deletion_policy = :never
write_mtls_headers = false

forwarded_client_cert_option = p("ha_proxy.forwarded_client_cert").downcase
case forwarded_client_cert_option
when "always_forward_only"
  # NOP
when "forward_only"
  if mutual_tls_enabled
    mtls_header_deletion_policy = :non_mtls_only
  else
    mtls_header_deletion_policy = :always
  end
when "sanitize_set"
  mtls_header_deletion_policy = :always
  write_mtls_headers = mutual_tls_enabled
when "forward_only_if_route_service"
  mtls_header_deletion_policy = :non_route_service_only
  write_mtls_headers = mutual_tls_enabled
else
  abort("Unknown 'forwarded_client_cert' option: #{forwarded_client_cert_option}. Known options: 'always_forward_only', 'forward_only', 'sanitize_set', 'forward_only_if_route_service'")
end

forward_true_client_ip_header = :forward_only_if_route_service
if_p("ha_proxy.true_client_ip_header") do
  if_p("ha_proxy.forward_true_client_ip_header") do
    case p("ha_proxy.forward_true_client_ip_header").downcase
      when "always_forward"
        forward_true_client_ip_header = :always_forward
      when "forward_only_if_route_service"
        forward_true_client_ip_header = :forward_only_if_route_service
      when "overwrite"
        forward_true_client_ip_header = :overwrite
      else
        abort("Unknown 'forward_true_client_ip_header' option: #{forward_true_client_ip_header}. Known options: 'always_forward', 'forward_only_if_route_service', 'overwrite'")
      end
  end
end

disable_domain_fronting = p("ha_proxy.disable_domain_fronting")
if ![true, false, "true", "false", "mtls_only"].include?(disable_domain_fronting)
  abort("Unknown 'disable_domain_fronting' option: #{disable_domain_fronting}. Known options: true, false or 'mtls_only'")
end

# }}}
# IPv4 and IPv6 binding (v4v6) Option {{{
v4v6 = ""
if_p("ha_proxy.v4v6") do
  if p("ha_proxy.binding_ip") == "::"
    v4v6 = "v4v6"
  end
end
# }}}

# ALPN Option {{{
default_alpn_config = ""
if p("ha_proxy.enable_http2")
  default_alpn_config = "alpn h2,http/1.1 "
end
# }}}

# Error checking
  if p("ha_proxy.accept_proxy", false) && p("ha_proxy.expect_proxy_cidrs", nil)
    abort "Conflicting configuration: accept_proxy and expect_proxy_cidrs are mutually exclusive"
  end
  if !p("ha_proxy.drain_enable", false) && p("ha_proxy.drain_frontend_grace_time") > 0
    abort "Conflicting configuration: drain_enable must be true to use drain_frontend_grace_time"
  end

  if !p("ha_proxy.hsts_enable", false)
    if p("ha_proxy.hsts_include_subdomains")
      abort "Conflicting configuration: hsts_enable must be true to use hsts_include_subdomains"
    end
    if p("ha_proxy.hsts_preload")
      abort "Conflicting configuration: hsts_enable must be true to enable hsts_preload"
    end
  end

  if p("ha_proxy.backend_ssl", "").downcase != "verify"
    if p("ha_proxy.backend_ssl_verifyhost", false)
      abort "Conflicting configuration: backend_ssl must be 'verify' to use backend_ssl_verifyhost"
    end
  end

  if !p("ha_proxy.client_cert", nil)
    if p("ha_proxy.client_cert_ignore_err", false)
      abort "Conflicting configuration: must enable client_cert to use client_cert_ignore_err"
    end

    if p("ha_proxy.client_revocation_list", false)
      abort "Conflicting configuration: must enable client_cert to use client_revocation_list"
    end
  end

  if p("ha_proxy.enable_4443") && !ssl_enabled
    abort "Conflicting configuration: if enable_4443 is true, you must provide a valid SSL config via ssl_pem or crt_list"
  end

  if p("ha_proxy.retries") == 0 && p("ha_proxy.enable_redispatch")
    abort "Conflicting configuration: enable_redispatch works only with retries > 0"
  end

  backend_servers = []
  backend_servers_local = []
  backend_port = nil
  if_link("http_backend") do |backend|
    backend_servers = backend.instances.map(&:address)
    backend_port = backend.p("port", p("ha_proxy.backend_port"))

    if p("ha_proxy.backend_prefer_local_az")
      backend_servers_local = backend.instances.select{ |n| n.az == spec.az }.map(&:address)
    end
  end.else_if_p("ha_proxy.backend_servers") do |servers|
    backend_servers = servers
    backend_port = p("ha_proxy.backend_port")
  end
  resolvers = ""
  if_p("ha_proxy.resolvers") do
    resolvers = "resolvers default "
  end
  backend_crt = ""
  if_p("ha_proxy.backend_crt") do
    backend_crt = "crt /var/vcap/jobs/haproxy/config/backend-crt.pem "
  end

  backend_ssl = ""
  if p("ha_proxy.backend_ssl").downcase == "verify"
    backend_ssl = "ssl verify required ca-file /var/vcap/jobs/haproxy/config/backend-ca-certs.pem "
    if_p("ha_proxy.backend_ssl_verifyhost") do | verify_hostname |
      backend_ssl += "verifyhost #{verify_hostname} "
    end
  elsif p("ha_proxy.backend_ssl").downcase == "noverify"
    backend_ssl = "ssl verify none "
  end

  backends = []
  disable_backend_http2_websockets = p("ha_proxy.disable_backend_http2_websockets")
  enable_http2 = p("ha_proxy.enable_http2")
  backend_match_http_protocol = p("ha_proxy.backend_match_http_protocol")

  if disable_backend_http2_websockets || (!enable_http2) || backend_match_http_protocol || backend_ssl == ""
    alpn = backend_ssl != "" ? "alpn http/1.1 " : ""
    backends += [{ name: "http-routers-http1", backend_ssl: backend_ssl, alpn: alpn }]
  end

  if backend_ssl != "" && (enable_http2 || backend_match_http_protocol)
    backends += [{ name: "http-routers-http2", backend_ssl: backend_ssl, alpn: "alpn h2,http/1.1 " }]
  end
-%>

global
    log <%= p('ha_proxy.syslog_server') %> len <%= p('ha_proxy.log_max_length') %> format <%= p('ha_proxy.log_format') %> syslog <%= p('ha_proxy.log_level') %>
    daemon
  <%- if properties.ha_proxy.global_config -%>
    <%= format_indented_multiline_config(p("ha_proxy.global_config")) %>
  <%- end -%>
  <%- if p("ha_proxy.nbthread") > 1 -%>
    nbthread <%= p("ha_proxy.nbthread") %>
  <%- end -%>
    user vcap
    group vcap
    maxconn <%= p("ha_proxy.max_connections") %>
    spread-checks 4
  <%- if_p("ha_proxy.reload_hard_stop_after") do -%>
    hard-stop-after <%= p("ha_proxy.reload_hard_stop_after") %>
  <%- end -%>
  <%- p("ha_proxy.lua_scripts").each do |script| -%>
    lua-load <%= script %>
  <%- end -%>
  <%- p("ha_proxy.lua_scripts_per_thread").each do |script| -%>
    lua-load-per-thread <%= script %>
  <%- end -%>
    tune.ssl.default-dh-param <%= p("ha_proxy.default_dh_param") %>
    tune.bufsize <%= p("ha_proxy.buffer_size_bytes") %>
  <%- if_p("ha_proxy.max_rewrite") do -%>
    tune.maxrewrite <%= p("ha_proxy.max_rewrite") %>
  <%- end -%>
    stats socket /var/vcap/sys/run/haproxy/stats.sock mode 600 expose-fd listeners level admin
    stats timeout 2m
    ssl-default-bind-options <%= ssl_flags %>
    ssl-default-bind-ciphers <%= p("ha_proxy.ssl_ciphers") %>
  <%- if_p("ha_proxy.ssl_ciphersuites") do -%>
    ssl-default-bind-ciphersuites <%= p("ha_proxy.ssl_ciphersuites") %>
  <%- end -%>
    ssl-default-server-options <%= ssl_flags %>
    ssl-default-server-ciphers <%= p("ha_proxy.ssl_ciphers") %>
  <%- if_p("ha_proxy.ssl_ciphersuites") do -%>
    ssl-default-server-ciphersuites <%= p("ha_proxy.ssl_ciphersuites") %>
  <%- end -%>
  <%- if backend_match_http_protocol && backends.length == 2 -%>
    set-var proc.h2_alpn_tag str(h2)
  <%- end -%>
  <%- if p("ha_proxy.always_allow_body_http10") %>
    h1-accept-payload-with-any-method
  <%- end %>

defaults
    log global
    option log-health-checks
    option log-separate-errors
    maxconn <%= p("ha_proxy.max_connections") %>
    option http-server-close
    <%- if_p("ha_proxy.reload_idle_close_on_response") do -%>
    option idle-close-on-response
    <%- end -%>
    option httplog
    option forwardfor
    option contstats
  <%- if p("ha_proxy.backend_prefer_local_az") -%>
    option allbackups
  <%- end -%>
  <%- if p("ha_proxy.enable_redispatch") -%>
    option redispatch
  <%- end -%>
  <%- if p("ha_proxy.retries") > 0 -%>
    retries <%= p("ha_proxy.retries") %>
  <%- end -%>

    timeout connect         <%= (p("ha_proxy.connect_timeout").to_f    * 1000).to_i %>ms
    timeout client          <%= (p("ha_proxy.client_timeout").to_f     * 1000).to_i %>ms
    timeout server          <%= (p("ha_proxy.server_timeout").to_f     * 1000).to_i %>ms
    timeout tunnel          <%= (p("ha_proxy.websocket_timeout").to_f  * 1000).to_i %>ms
    timeout http-keep-alive <%= (p("ha_proxy.keepalive_timeout").to_f  * 1000).to_i %>ms
    timeout http-request    <%= (p("ha_proxy.request_timeout").to_f    * 1000).to_i %>ms
    timeout queue           <%= (p("ha_proxy.queue_timeout").to_f      * 1000).to_i %>ms
    <%- if properties.ha_proxy.default_config -%>
    <%= format_indented_multiline_config(p("ha_proxy.default_config")) %>
    <%- end -%>

<% if p("ha_proxy.stats_enable") -%>
listen stats
    bind <%= stat_prefix %><%= stat_port %>
    acl private src <%= p("ha_proxy.trusted_stats_cidrs") %>
    http-request deny unless private
    mode http
  <%- if_p("ha_proxy.stats_promex_enable") do -%>
    http-request use-service prometheus-exporter if { path <%= p("ha_proxy.stats_promex_path") %> }
  <%- end -%>
    stats enable
    stats hide-version
    stats realm "Haproxy Statistics"
    stats uri /<%= p("ha_proxy.stats_uri") %>
    <%- if_p("ha_proxy.stats_user") do |stats_user| -%>
      <%- if stats_user != "" -%>
    stats auth <%= stats_user %>:<%= p("ha_proxy.stats_password") %>
      <%- end -%>
    <%end -%>
<% end -%>

<% if p("ha_proxy.enable_health_check_http") %>
listen health_check_http_url
    bind :<%= p("ha_proxy.health_check_port") %>
    mode http
    option httpclose
    monitor-uri /health
    <%- if p("ha_proxy.accept_proxy") && !p("ha_proxy.disable_health_check_proxy") -%>
    tcp-request connection expect-proxy layer4 unless LOCALHOST
    <%- end -%>

    acl http-routers_down nbsrv(<%= backends.first[:name] %>) eq 0
    monitor fail if http-routers_down

<%- if p("ha_proxy.expect_proxy_cidrs", []).size > 0 -%>
listen health_check_http_url_proxy_protocol
    bind :<%= p("ha_proxy.health_check_port") + 1 %> accept-proxy
    mode http
    option httpclose
    monitor-uri /health
    acl http-routers_down nbsrv(<%= backends.first[:name] %>) eq 0
    monitor fail if http-routers_down
<% end -%>
<%- end -%>

<% if_p("ha_proxy.resolvers") do |resolvers| -%>
resolvers default
    hold valid <%= p("ha_proxy.dns_hold") %>
    timeout retry <%= p("ha_proxy.resolve_retry_timeout") %>
    resolve_retries <%= p("ha_proxy.resolve_retries") %>
  <%- resolvers.each do |resolver| -%>
    nameserver <%= resolver.keys[0] %> <%= resolver.values[0] %>:53
  <%- end -%>
<% end -%>

<% if_p("ha_proxy.requests_rate_limit.table_size", "ha_proxy.requests_rate_limit.window_size") do |table_size, window_size| %>
backend st_http_req_rate
    stick-table type ipv6 size <%= table_size %> expire <%= window_size %> store http_req_rate(<%= window_size %>)
<% end %>

<% if_p("ha_proxy.connections_rate_limit.table_size", "ha_proxy.connections_rate_limit.window_size") do |table_size, window_size| %>
backend st_tcp_conn_rate
    stick-table type ipv6 size <%= table_size %> expire <%= window_size %> store conn_rate(<%= window_size %>)
<% end %>

<% unless p("ha_proxy.disable_http") -%>
# HTTP Frontend {{{
frontend http-in
    mode http
    bind <%= p("ha_proxy.binding_ip") %>:80 <%= accept_proxy %> <%= v4v6 %>
  <%- if properties.ha_proxy.frontend_config -%>
    <%= format_indented_multiline_config(p("ha_proxy.frontend_config")) %>
  <%- end -%>
  <%- if_p("ha_proxy.connections_rate_limit.table_size", "ha_proxy.connections_rate_limit.window_size") do -%>
    tcp-request connection track-sc0 src table st_tcp_conn_rate
    <%- if_p("ha_proxy.connections_rate_limit.block", "ha_proxy.connections_rate_limit.connections") do |block, connections| -%>
      <%-if block -%>
    tcp-request connection reject if { sc_conn_rate(0) gt <%= connections %> }
      <%- end -%>
    <%- end -%>
  <%- end -%>
  <%- if_p("ha_proxy.requests_rate_limit.table_size", "ha_proxy.requests_rate_limit.window_size") do -%>
    http-request track-sc1 src table st_http_req_rate
    <%- if_p("ha_proxy.requests_rate_limit.block", "ha_proxy.requests_rate_limit.requests") do |block, requests| -%>
      <%-if block -%>
    http-request deny status 429 if { sc_http_req_rate(1) gt <%= requests %> }
      <%- end -%>
    <%- end -%>
  <%- end -%>
  <%- if p("ha_proxy.expect_proxy_cidrs", []).size > 0 -%>
    tcp-request connection expect-proxy layer4 if { src -f /var/vcap/jobs/haproxy/config/expect_proxy_cidrs.txt }
  <%- end -%>
  <%- if_p("ha_proxy.cidr_whitelist") do -%>
    acl whitelist src -f /var/vcap/jobs/haproxy/config/whitelist_cidrs.txt
    tcp-request content accept if whitelist
  <%- end -%>
  <%- if_p("ha_proxy.cidr_blacklist") do -%>
    acl blacklist src -f /var/vcap/jobs/haproxy/config/blacklist_cidrs.txt
    tcp-request content reject if blacklist
  <%- end -%>
  <%- if p("ha_proxy.block_all")  -%>
    tcp-request content reject
  <%- end -%>
    capture request header Host len 256
    default_backend <%= backends.last[:name] %>
  <%- if_p("ha_proxy.http_request_deny_conditions") do |conditions| -%>
    <%- conditions.each do |condition| -%>
      <%- acl_names="" -%>
      <%- condition["condition"].each do |acl| -%>
    acl <%= acl["acl_name"] %> <%= acl["acl_rule"] %>
        <%- if acl.key?("negate") && acl["negate"] -%>
          <%- acl_names=acl_names+"!"+acl["acl_name"]+" " -%>
        <%- else %>
          <%- acl_names=acl_names+acl["acl_name"]+" " -%>
        <%- end -%>
      <%- end -%>
    http-request deny if <%= acl_names %>
    <%- end -%>
  <%- end -%>
  <%- if_p("ha_proxy.strip_headers") do |headers| -%>
    <%- headers.each do |header| -%>
     http-request del-header <%= header.gsub(/(?!:\\)( )/, '\ ') %>
    <%- end -%>
  <%- end -%>
  <%- if_p("ha_proxy.headers") do |headers| -%>
    <%- headers.each do |header, value| -%>
    http-request add-header <%= header.gsub(/(?!:\\)( )/, '\ ') %> "<%= value.to_s.gsub(/(?!:\\) /, '\ ') %>"
    <%- end -%>
  <%- end -%>
  <%- if_p("ha_proxy.rsp_headers") do |rsp_headers| -%>
    <%- rsp_headers.each do |rsp_header, value| -%>
    http-response add-header <%= rsp_header.gsub(/(?!:\\)( )/, '\ ') %> "<%= value.to_s.gsub(/(?!:\\) /, '\ ') %>"
    <%- end -%>
  <%- end -%>
  <%- if_p("ha_proxy.true_client_ip_header") do |header| -%>
    http-request set-header <%= header %> %[src]
  <%- end -%>
  <%- if p("ha_proxy.internal_only_domains").size > 0 -%>
    acl private src -f /var/vcap/jobs/haproxy/config/trusted_domain_cidrs.txt
    <%- p("ha_proxy.internal_only_domains").each do |domain| -%>
    acl internal hdr(Host) -m sub <%= domain %>
    <%- end -%>
    http-request deny if internal !private
  <%- end -%>
  <%- p('ha_proxy.routed_backend_servers').each do |prefix, data| -%>
    <%-
      prefix_hash = (Digest::SHA256.hexdigest prefix.to_s)[0..5]
      acls = ["path_beg #{prefix}"].concat(data.fetch("additional_acls", []))
      acl_hash = acls.each_with_index.map { |rule, i| ["routed_backend_#{prefix_hash}_#{i}", rule] }.to_h
    -%>
    <%- acl_hash.each do |name, rule| %>
    acl <%= name %> <%= rule %>
    <%- end -%>
    use_backend http-routed-backend-<%= prefix_hash %> if <%= acl_hash.keys.join " " %>
  <%- end -%>
    acl xfp_exists hdr_cnt(X-Forwarded-Proto) gt 0
    http-request add-header X-Forwarded-Proto "http" if ! xfp_exists
  <%- if p("ha_proxy.https_redirect_all") -%>
    redirect scheme https code 301 if !{ ssl_fc }
  <%- end -%>
  <%- unless p("ha_proxy.https_redirect_all") -%>
    acl ssl_redirect hdr(host),lower,map_end(/var/vcap/jobs/haproxy/config/ssl_redirect.map,false) -m str true
    redirect scheme https code 301 if ssl_redirect
  <%- end -%>

  <%- if p("ha_proxy.disable_backend_http2_websockets") -%>
    # Send websockets to a backend that forces HTTP/1.1. This avoids bugs in Go & Gorouter's HTTP/2 websocket support
    # https://github.com/cloudfoundry/routing-release/issues/230
    # Note: first matching backend will be used when there are multiple use_backend directives
    acl is_websocket hdr(Upgrade) -i WebSocket
    acl is_websocket hdr_beg(Host) -i ws
    use_backend http-routers-http1 if is_websocket
  <%- end -%>
# }}}
<% end -%>

<% if ssl_enabled -%>
# HTTPS Frontend {{{
frontend https-in
    mode http
    bind <%= p("ha_proxy.binding_ip") %>:443 <%= accept_proxy %> <%= tls_bind_options %> <%= v4v6 %> <%= default_alpn_config %>
    # Set this acl when the request is a route service request, used by ha_proxy.forward_true_client_ip_header and ha_proxy.forwarded_client_cert
    acl route_service_request hdr(X-Cf-Proxy-Signature) -m found
  <%- if disable_domain_fronting -%>
    # Check whether the client is attempting domain fronting.
    # Ensure a host header exists to check against
    http-request deny deny_status 400 content-type text/plain string "400 Bad Request: missing required Host header" if { req.hdr_cnt(host) eq 0 }
    # Ignore optional port in Host header when comparing to SNI
    http-request set-var(txn.host) hdr(host),host_only
    acl ssl_sni_http_host_match ssl_fc_sni,lower,strcmp(txn.host) eq 0
    <%- if disable_domain_fronting  == 'mtls_only' %>
    http-request deny deny_status 421 if { ssl_fc_has_sni } { ssl_c_used } !ssl_sni_http_host_match
    <%- elsif [true, "true"].include?(disable_domain_fronting) -%>
    http-request deny deny_status 421 if { ssl_fc_has_sni } !ssl_sni_http_host_match
    <%- end -%>
  <%- end -%>
  <%- if properties.ha_proxy.frontend_config -%>
    <%= format_indented_multiline_config(p("ha_proxy.frontend_config")) %>
  <%- end -%>
  <%- if_p("ha_proxy.connections_rate_limit.table_size", "ha_proxy.connections_rate_limit.window_size") do -%>
    tcp-request connection track-sc0 src table st_tcp_conn_rate
    <%- if_p("ha_proxy.connections_rate_limit.block", "ha_proxy.connections_rate_limit.connections") do |block, connections| -%>
      <%-if block -%>
    tcp-request connection reject if { sc_conn_rate(0) gt <%= connections %> }
      <%- end -%>
    <%- end -%>
  <%- end -%>
  <%- if_p("ha_proxy.requests_rate_limit.table_size", "ha_proxy.requests_rate_limit.window_size") do -%>
    http-request track-sc1 src table st_http_req_rate
    <%- if_p("ha_proxy.requests_rate_limit.block", "ha_proxy.requests_rate_limit.requests") do |block, requests| -%>
      <%-if block -%>
    http-request deny status 429 if { sc_http_req_rate(1) gt <%= requests %> }
      <%- end -%>
    <%- end -%>
  <%- end -%>
  <%- if p("ha_proxy.expect_proxy_cidrs", []).size > 0 -%>
        tcp-request connection expect-proxy layer4 if { src -f /var/vcap/jobs/haproxy/config/expect_proxy_cidrs.txt }
  <%- end -%>
  <%- if_p("ha_proxy.cidr_whitelist") do -%>
    acl whitelist src -f /var/vcap/jobs/haproxy/config/whitelist_cidrs.txt
    tcp-request content accept if whitelist
  <%- end -%>
  <%- if_p("ha_proxy.cidr_blacklist") do -%>
    acl blacklist src -f /var/vcap/jobs/haproxy/config/blacklist_cidrs.txt
    tcp-request content reject if blacklist
  <%- end -%>
  <%- if p("ha_proxy.block_all")  -%>
    tcp-request content reject
  <%- end -%>

  <%- case mtls_header_deletion_policy -%>
  <%- when :always -%>
    http-request del-header X-Forwarded-Client-Cert
    http-request del-header X-SSL-Client
    http-request del-header X-SSL-Client-Session-ID
    http-request del-header X-SSL-Client-Verify
    http-request del-header X-SSL-Client-Subject-DN
    http-request del-header X-SSL-Client-Subject-CN
    http-request del-header X-SSL-Client-Issuer-DN
    http-request del-header X-SSL-Client-NotBefore
    http-request del-header X-SSL-Client-NotAfter
    http-request del-header X-SSL-Client-Root-CA-DN
  <%- when :non_mtls_only -%>
    http-request del-header X-Forwarded-Client-Cert if ! { ssl_c_used }
    http-request del-header X-SSL-Client            if ! { ssl_c_used }
    http-request del-header X-SSL-Client-Session-ID if ! { ssl_c_used }
    http-request del-header X-SSL-Client-Verify     if ! { ssl_c_used }
    http-request del-header X-SSL-Client-Subject-DN if ! { ssl_c_used }
    http-request del-header X-SSL-Client-Subject-CN if ! { ssl_c_used }
    http-request del-header X-SSL-Client-Issuer-DN  if ! { ssl_c_used }
    http-request del-header X-SSL-Client-NotBefore  if ! { ssl_c_used }
    http-request del-header X-SSL-Client-NotAfter   if ! { ssl_c_used }
    http-request del-header X-SSL-Client-Root-CA-DN if ! { ssl_c_used }
  <%- when :non_route_service_only -%>
    http-request del-header X-Forwarded-Client-Cert if !route_service_request
    http-request del-header X-SSL-Client            if !route_service_request
    http-request del-header X-SSL-Client-Session-ID if !route_service_request
    http-request del-header X-SSL-Client-Verify     if !route_service_request
    http-request del-header X-SSL-Client-Subject-DN if !route_service_request
    http-request del-header X-SSL-Client-Subject-CN if !route_service_request
    http-request del-header X-SSL-Client-Issuer-DN  if !route_service_request
    http-request del-header X-SSL-Client-NotBefore  if !route_service_request
    http-request del-header X-SSL-Client-NotAfter   if !route_service_request
    http-request del-header X-SSL-Client-Root-CA-DN if !route_service_request
  <%- end -%>

  <%- if write_mtls_headers -%>
    http-request set-header X-Forwarded-Client-Cert %[ssl_c_der,base64]          if { ssl_c_used }
    http-request set-header X-SSL-Client            %[ssl_c_used]                if { ssl_c_used }
    http-request set-header X-SSL-Client-Session-ID %[ssl_fc_session_id,hex]     if { ssl_c_used }
    http-request set-header X-SSL-Client-Verify     %[ssl_c_verify]              if { ssl_c_used }
    http-request set-header X-SSL-Client-NotBefore  %{+Q}[ssl_c_notbefore]       if { ssl_c_used }
    http-request set-header X-SSL-Client-NotAfter   %{+Q}[ssl_c_notafter]        if { ssl_c_used }
    <%- if p("ha_proxy.legacy_xfcc_header_mapping") %>
    http-request set-header X-SSL-Client-Subject-DN %{+Q}[ssl_c_s_dn]            if { ssl_c_used }
    http-request set-header X-SSL-Client-Subject-CN %{+Q}[ssl_c_s_dn(cn)]        if { ssl_c_used }
    http-request set-header X-SSL-Client-Issuer-DN  %{+Q}[ssl_c_i_dn]            if { ssl_c_used }
    http-request set-header X-SSL-Client-Root-CA-DN %{+Q}[ssl_c_r_dn]            if { ssl_c_used }
    <%- else %>
    http-request set-header X-SSL-Client-Subject-DN %{+Q}[ssl_c_s_dn,base64]     if { ssl_c_used }
    http-request set-header X-SSL-Client-Subject-CN %{+Q}[ssl_c_s_dn(cn),base64] if { ssl_c_used }
    http-request set-header X-SSL-Client-Issuer-DN  %{+Q}[ssl_c_i_dn,base64]     if { ssl_c_used }
    http-request set-header X-SSL-Client-Root-CA-DN %{+Q}[ssl_c_r_dn,base64]     if { ssl_c_used }
    <%- end %>
  <%- end -%>

  <%- if p("ha_proxy.hsts_enable") -%>
    http-response set-header Strict-Transport-Security max-age=<%= p("ha_proxy.hsts_max_age").to_i %>;<% if p("ha_proxy.hsts_include_subdomains") %>\ includeSubDomains;<% end %><% if p("ha_proxy.hsts_preload") %>\ preload;<% end %>
  <%- end -%>
    capture request header Host len 256
    default_backend <%= backends.last[:name] %>
  <%- if_p("ha_proxy.http_request_deny_conditions") do |conditions| -%>
    <%- conditions.each do |condition| -%>
      <%- acl_names="" -%>
      <%- condition["condition"].each do |acl| -%>
    acl <%= acl["acl_name"] %> <%= acl["acl_rule"] %>
        <%- if acl.key?("negate") && acl["negate"] -%>
          <%- acl_names=acl_names+"!"+acl["acl_name"]+" " -%>
        <%- else %>
          <%- acl_names=acl_names+acl["acl_name"]+" " -%>
        <%- end -%>
      <%- end -%>
    http-request deny if <%= acl_names %>
    <%- end -%>
  <%- end -%>
  <%- if_p("ha_proxy.strip_headers") do |strip_headers| -%>
    <%- strip_headers.each do |strip_header| -%>
    http-request del-header <%= strip_header.gsub(/(?!:\\)( )/, '\ ') %>
    <%- end -%>
  <%- end -%>
  <%- if_p("ha_proxy.headers") do |headers| -%>
    <%- headers.each do |header, value| -%>
    http-request add-header <%= header.gsub(/(?!:\\)( )/, '\ ') %> "<%= value.to_s.gsub(/(?!:\\) /, '\ ') %>"
    <%- end -%>
  <%- end -%>
  <%- if_p("ha_proxy.rsp_headers") do |rsp_headers| -%>
    <%- rsp_headers.each do |rsp_header, value| -%>
    http-response add-header <%= rsp_header.gsub(/(?!:\\)( )/, '\ ') %> "<%= value.to_s.gsub(/(?!:\\) /, '\ ') %>"
    <%- end -%>
  <%- end -%>
  <%- if_p("ha_proxy.true_client_ip_header") do |header| -%>
    <%- case forward_true_client_ip_header -%>
    <%- when  :always_forward -%>
      # only set the header if it is not already set
      acl true_client_ip_request hdr(<%= header %>) -m found
      http-request set-header <%= header %> %[src] if !true_client_ip_request
    <%- when  :overwrite -%>
      # always set header
      http-request set-header <%= header %> %[src]
    <%- when  :forward_only_if_route_service -%>
      acl true_client_ip_request hdr(<%= header %>) -m found
      http-request set-header <%= header %> %[src] if !true_client_ip_request or route_service_request
    <%- end -%>
  <%- end -%>
  <%- if p("ha_proxy.internal_only_domains").size > 0 -%>
    acl private src -f /var/vcap/jobs/haproxy/config/trusted_domain_cidrs.txt
    <%- p("ha_proxy.internal_only_domains").each do |domain| -%>
    acl internal hdr(Host) -m sub <%= domain %>
    <%- end -%>
    http-request deny if internal !private
  <%- end -%>
  <%- p('ha_proxy.routed_backend_servers').each do |prefix, data| -%>
    <%-
      prefix_hash = (Digest::SHA256.hexdigest prefix.to_s)[0..5]
      acls = ["path_beg #{prefix}"].concat(data.fetch("additional_acls", []))
      acl_hash = acls.each_with_index.map { |rule, i| ["routed_backend_#{prefix_hash}_#{i}", rule] }.to_h
    -%>
    <%- acl_hash.each do |name, rule| %>
    acl <%= name %> <%= rule %>
    <%- end -%>
    use_backend http-routed-backend-<%= prefix_hash %> if <%= acl_hash.keys.join " " %>
  <%- end -%>
    acl xfp_exists hdr_cnt(X-Forwarded-Proto) gt 0
    http-request add-header X-Forwarded-Proto "https" if ! xfp_exists
  <%- if p("ha_proxy.disable_backend_http2_websockets") -%>
    # Send websockets to a backend that forces HTTP/1.1. This avoids bugs in Go & Gorouter's HTTP/2 websocket support
    # https://github.com/cloudfoundry/routing-release/issues/230
    # Note: first matching backend will be used when there are multiple use_backend directives
    acl is_websocket hdr(Upgrade) -i WebSocket
    acl is_websocket hdr_beg(Host) -i ws
    use_backend http-routers-http1 if is_websocket
  <%- end -%>

  <%- if backend_match_http_protocol && backends.length == 2 -%>
    # Ensure that backend protocol matches frontend protocol
    # Note: first matching backend will be used when there are multiple use_backend directives
    acl is_http2 ssl_fc_alpn,lower,strcmp(proc.h2_alpn_tag) eq 0
    use_backend http-routers-http1 if ! is_http2
    use_backend http-routers-http2 if is_http2
  <%- end -%>
# }}}
<% end -%>

<% if p("ha_proxy.enable_4443") -%>
# HTTPS Websockets Frontend {{{
frontend wss-in
    mode http
    bind <%= p("ha_proxy.binding_ip") %>:4443 <%= accept_proxy %> <%= tls_bind_options %> <%= v4v6 %>
  <%- if disable_domain_fronting -%>
    # Check whether the client is attempting domain fronting.
    # Ensure a host header exists to check against
    http-request deny deny_status 400 content-type text/plain string "400 Bad Request: missing required Host header" if { req.hdr_cnt(host) eq 0 }
    # Ignore optional port in Host header when comparing to SNI
    http-request set-var(txn.host) hdr(host),host_only
    acl ssl_sni_http_host_match ssl_fc_sni,lower,strcmp(txn.host) eq 0
    <%- if disable_domain_fronting  == 'mtls_only' %>
    http-request deny deny_status 421 if { ssl_fc_has_sni } { ssl_c_used } !ssl_sni_http_host_match
    <%- elsif [true, "true"].include?(disable_domain_fronting) -%>
    http-request deny deny_status 421 if { ssl_fc_has_sni } !ssl_sni_http_host_match
    <%- end -%>
  <%- end -%>
  <%- if properties.ha_proxy.frontend_config -%>
    <%= format_indented_multiline_config(p("ha_proxy.frontend_config")) %>
  <%- end -%>
  <%- if p("ha_proxy.expect_proxy_cidrs", []).size > 0 -%>
    tcp-request connection expect-proxy layer4 if { src -f /var/vcap/jobs/haproxy/config/expect_proxy_cidrs.txt }
  <%- end -%>
  <%- if_p("ha_proxy.cidr_whitelist") do -%>
    acl whitelist src -f /var/vcap/jobs/haproxy/config/whitelist_cidrs.txt
    tcp-request content accept if whitelist
  <%- end -%>
  <%- if_p("ha_proxy.cidr_blacklist") do -%>
    acl blacklist src -f /var/vcap/jobs/haproxy/config/blacklist_cidrs.txt
    tcp-request content reject if blacklist
  <%- end -%>
  <%- if p("ha_proxy.block_all")  -%>
    tcp-request content reject
  <%- end -%>

  <%- case mtls_header_deletion_policy -%>
  <%- when :always -%>
    http-request del-header X-Forwarded-Client-Cert
    http-request del-header X-SSL-Client
    http-request del-header X-SSL-Client-Session-ID
    http-request del-header X-SSL-Client-Verify
    http-request del-header X-SSL-Client-Subject-DN
    http-request del-header X-SSL-Client-Subject-CN
    http-request del-header X-SSL-Client-Issuer-DN
    http-request del-header X-SSL-Client-NotBefore
    http-request del-header X-SSL-Client-NotAfter
    http-request del-header X-SSL-Client-Root-CA-DN
  <%- when :non_mtls_only -%>
    http-request del-header X-Forwarded-Client-Cert if ! { ssl_c_used }
    http-request del-header X-SSL-Client            if ! { ssl_c_used }
    http-request del-header X-SSL-Client-Session-ID if ! { ssl_c_used }
    http-request del-header X-SSL-Client-Verify     if ! { ssl_c_used }
    http-request del-header X-SSL-Client-Subject-DN if ! { ssl_c_used }
    http-request del-header X-SSL-Client-Subject-CN if ! { ssl_c_used }
    http-request del-header X-SSL-Client-Issuer-DN  if ! { ssl_c_used }
    http-request del-header X-SSL-Client-NotBefore  if ! { ssl_c_used }
    http-request del-header X-SSL-Client-NotAfter   if ! { ssl_c_used }
    http-request del-header X-SSL-Client-Root-CA-DN if ! { ssl_c_used }
  <%- when :non_route_service_only -%>
    acl route_service_request hdr(X-Cf-Proxy-Signature) -m found
    http-request del-header X-Forwarded-Client-Cert if !route_service_request
    http-request del-header X-SSL-Client            if !route_service_request
    http-request del-header X-SSL-Client-Session-ID if !route_service_request
    http-request del-header X-SSL-Client-Verify     if !route_service_request
    http-request del-header X-SSL-Client-Subject-DN if !route_service_request
    http-request del-header X-SSL-Client-Subject-CN if !route_service_request
    http-request del-header X-SSL-Client-Issuer-DN  if !route_service_request
    http-request del-header X-SSL-Client-NotBefore  if !route_service_request
    http-request del-header X-SSL-Client-NotAfter   if !route_service_request
    http-request del-header X-SSL-Client-Root-CA-DN if !route_service_request
  <%- end -%>

  <%- if write_mtls_headers -%>
    http-request set-header X-Forwarded-Client-Cert %[ssl_c_der,base64]          if { ssl_c_used }
    http-request set-header X-SSL-Client            %[ssl_c_used]                if { ssl_c_used }
    http-request set-header X-SSL-Client-Session-ID %[ssl_fc_session_id,hex]     if { ssl_c_used }
    http-request set-header X-SSL-Client-Verify     %[ssl_c_verify]              if { ssl_c_used }
    http-request set-header X-SSL-Client-NotBefore  %{+Q}[ssl_c_notbefore]       if { ssl_c_used }
    http-request set-header X-SSL-Client-NotAfter   %{+Q}[ssl_c_notafter]        if { ssl_c_used }
    <%- if p("ha_proxy.legacy_xfcc_header_mapping") %>
    http-request set-header X-SSL-Client-Subject-DN %{+Q}[ssl_c_s_dn]            if { ssl_c_used }
    http-request set-header X-SSL-Client-Subject-CN %{+Q}[ssl_c_s_dn(cn)]        if { ssl_c_used }
    http-request set-header X-SSL-Client-Issuer-DN  %{+Q}[ssl_c_i_dn]            if { ssl_c_used }
    http-request set-header X-SSL-Client-Root-CA-DN %{+Q}[ssl_c_r_dn]            if { ssl_c_used }
    <%- else %>
    http-request set-header X-SSL-Client-Subject-DN %{+Q}[ssl_c_s_dn,base64]     if { ssl_c_used }
    http-request set-header X-SSL-Client-Subject-CN %{+Q}[ssl_c_s_dn(cn),base64] if { ssl_c_used }
    http-request set-header X-SSL-Client-Issuer-DN  %{+Q}[ssl_c_i_dn,base64]     if { ssl_c_used }
    http-request set-header X-SSL-Client-Root-CA-DN %{+Q}[ssl_c_r_dn,base64]     if { ssl_c_used }
    <%- end %>
  <%- end -%>

  <%- if p("ha_proxy.hsts_enable") -%>
    http-response set-header Strict-Transport-Security max-age=<%= p("ha_proxy.hsts_max_age").to_i %>;<% if p("ha_proxy.hsts_include_subdomains") %>\ includeSubDomains;<% end %><% if p("ha_proxy.hsts_preload") %>\ preload;<% end %>
  <%- end -%>
    capture request header Host len 256
    default_backend <%= backends.last[:name] %>
  <%- if_p("ha_proxy.http_request_deny_conditions") do |conditions| -%>
    <%- conditions.each do |condition| -%>
      <%- acl_names="" -%>
      <%- condition["condition"].each do |acl| -%>
    acl <%= acl["acl_name"] %> <%= acl["acl_rule"] %>
        <%- if acl.key?("negate") && acl["negate"] -%>
          <%- acl_names=acl_names+"!"+acl["acl_name"]+" " -%>
        <%- else %>
          <%- acl_names=acl_names+acl["acl_name"]+" " -%>
        <%- end -%>
      <%- end -%>
    http-request deny if <%= acl_names %>
    <%- end -%>
  <%- end -%>
  <%- if_p("ha_proxy.strip_headers") do |headers| -%>
    <%- headers.each do |header| -%>
      http-request del-header <%= header.gsub(/(?!:\\)( )/, '\ ') %>
    <%- end -%>
  <%- end -%>
  <%- if_p("ha_proxy.headers") do |headers| -%>
    <%- headers.each do |header, value| -%>
    http-request add-header <%= header.gsub(/(?!:\\)( )/, '\ ') %> "<%= value.to_s.gsub(/(?!:\\) /, '\ ') %>"
    <%- end -%>
  <%- end -%>
  <%- if_p("ha_proxy.rsp_headers") do |rsp_headers| -%>
    <%- rsp_headers.each do |rsp_header, value| -%>
    http-response add-header <%= rsp_header.gsub(/(?!:\\)( )/, '\ ') %> "<%= value.to_s.gsub(/(?!:\\) /, '\ ') %>"
    <%- end -%>
  <%- end -%>
  <%- if p("ha_proxy.internal_only_domains").size > 0 -%>
    acl private src -f /var/vcap/jobs/haproxy/config/trusted_domain_cidrs.txt
    <%- p("ha_proxy.internal_only_domains").each do |domain| -%>
    acl internal hdr(Host) -m sub <%= domain %>
    <%- end -%>
    http-request deny if internal !private
  <%- end -%>
  <%- p('ha_proxy.routed_backend_servers').each do |prefix, data| -%>
    <%-
      prefix_hash = (Digest::SHA256.hexdigest prefix.to_s)[0..5]
      acls = ["path_beg #{prefix}"].concat(data.fetch("additional_acls", []))
      acl_hash = acls.each_with_index.map { |rule, i| ["routed_backend_#{prefix_hash}_#{i}", rule] }.to_h
    -%>
    <%- acl_hash.each do |name, rule| %>
    acl <%= name %> <%= rule %>
    <%- end -%>
    use_backend http-routed-backend-<%= prefix_hash %> if <%= acl_hash.keys.join " " %>
  <%- end -%>
    acl xfp_exists hdr_cnt(X-Forwarded-Proto) gt 0
    http-request add-header X-Forwarded-Proto "https" if ! xfp_exists
  <%- if p("ha_proxy.disable_backend_http2_websockets") -%>
    # Send websockets to a backend that forces HTTP/1.1. This avoids bugs in Go & Gorouter's HTTP/2 websocket support
    # https://github.com/cloudfoundry/routing-release/issues/230
    acl is_websocket hdr(Upgrade) -i WebSocket
    acl is_websocket hdr_beg(Host) -i ws
    use_backend http-routers-http1 if is_websocket
  <%- end -%>

  <%- if backend_match_http_protocol && backends.length == 2 -%>
    # Ensure that backend protocol matches frontend protocol
    # Note: first matching backend will be used when there are multiple use_backend directives
    acl is_http2 ssl_fc_alpn,lower,strcmp(proc.h2_alpn_tag) eq 0
    use_backend http-routers-http1 if ! is_http2
    use_backend http-routers-http2 if is_http2
  <%- end -%>
# }}}
<% end -%>

<%-
  backends.each do |backend|
-%>
# Backend <%= backend[:name] %> {{{
backend <%= backend[:name] %>
    mode http
    balance roundrobin
  <%- if p("ha_proxy.compress_types") != "" -%>
    compression algo gzip
    compression type <%= p("ha_proxy.compress_types") %>
  <%- end -%>
  <%- if properties.ha_proxy.backend_config -%>
    <%= format_indented_multiline_config(p("ha_proxy.backend_config")) %>
  <%- end -%>
  <%- backend_configs = p('ha_proxy.backend_config_targeted', {})  -%>
  <%- backend_configs.keys.each do |backend_name| -%>
  <%- if backend[:name] == backend_name -%>
    <%= format_indented_multiline_config(backend_configs[backend_name]) -%>
    <%- end -%>
  <%- end -%>

    <%- p('ha_proxy.custom_http_error_files', {}).keys.each do |status_code| -%>
        errorfile <%= status_code %> /var/vcap/jobs/haproxy/errorfiles/custom<%=status_code%>.http
    <%- end -%>
    <%
-%>
  <%- if p("ha_proxy.backend_use_http_health") == true  -%>
    option httpchk GET <%= p("ha_proxy.backend_http_health_uri") %>
    <%- health_check_options = "port " + p("ha_proxy.backend_http_health_port").to_s -%>
    <%- health_check_options += " fall " + p("ha_proxy.backend_health_fall").to_s -%>
    <%- health_check_options += " rise " + p("ha_proxy.backend_health_rise").to_s -%>
    <%- p("ha_proxy.backend_https_check") ? ssl_check = " check-ssl" : ssl_check = nil -%>
  <%- end -%>

  <% backend_servers.each_with_index do |ip, index| %>
    server node<%= index %> <%= ip %>:<%= backend_port -%> <%= resolvers -%><%= backend_crt -%>check<%= ssl_check -%> inter 1000 <%= health_check_options %> <%= backend[:backend_ssl] %><%= backend[:alpn] %><%- if !backend_servers_local.empty? && !backend_servers_local.include?(ip)  -%> backup<%- end -%>
  <% end %>
# }}}
<%- end %>


# Routed Backends {{{
<% p('ha_proxy.routed_backend_servers').each do |prefix, data| -%>
  <%- prefix_hash = (Digest::SHA256.hexdigest prefix.to_s)[0..5] -%>
backend http-routed-backend-<%= prefix_hash %>
    mode http
    balance roundrobin
  <%- if p("ha_proxy.compress_types") != "" -%>
    compression algo gzip
    compression type <%= p("ha_proxy.compress_types") %>
  <%- end -%>
  <%- if properties.ha_proxy.backend_config -%>
    <%= format_indented_multiline_config(p("ha_proxy.backend_config")) %>
  <%- end -%>
<%
  resolvers = ""
  if_p("ha_proxy.resolvers") do
    resolvers = "resolvers default "
  end
  backend_ssl = ""

  if (data["backend_ssl"] || "").downcase != "verify"
    if data["backend_verifyhost"]
      abort "Conflicting configuration: backend_ssl must be 'verify' to use backend_verifyhost in routed_backend_servers"
    end
  end

  if data["backend_ssl"]
    if data["backend_ssl"].downcase == "verify"
      backend_ssl = "ssl verify required ca-file /var/vcap/jobs/haproxy/config/backend-ca-certs.pem "
      if data["backend_verifyhost"]
        backend_ssl += "verifyhost #{data["backend_verifyhost"]} "
      end
      backend_ssl += default_alpn_config
    elsif data["backend_ssl"].downcase == "noverify"
      backend_ssl = "ssl verify none "
      backend_ssl += default_alpn_config
    end
  end
-%>
  <%- if data["backend_use_http_health"] == true  -%>
    <%- data["backend_http_health_port"] ||= data["port"] -%>
    <%- data["backend_http_health_uri"] ||= "/health" -%>
    option httpchk GET <%= data["backend_http_health_uri"] %>
    <%- routed_health_check_options = " port " + data["backend_http_health_port"].to_s -%>
    <%- if data["backend_health_fall"] -%>
      <%- routed_health_check_options += " fall " + data["backend_health_fall"].to_s -%>
    <%- end -%>
    <%- if data["backend_health_rise"] -%>
      <%- routed_health_check_options += " rise " + data["backend_health_rise"].to_s -%>
    <%- end -%>
  <%- end -%>
  <% data["servers"].each_with_index do |ip, index| %>
    server node<%= index %> <%= ip %>:<%= data["port"] %> <%= resolvers -%>check inter 1000<%= routed_health_check_options %> <%= backend_ssl %>
  <% end %>
<% end -%>
# }}}

# TCP Routing  {{{
<% if_link("tcp_router") do |tcp_router| -%>

frontend cf_tcp_routing
    mode tcp
    bind <%= p("ha_proxy.binding_ip") %>:<%= p("ha_proxy.tcp_routing.port_range") %> <%= v4v6 %>
    default_backend cf_tcp_routers

backend cf_tcp_routers
    mode tcp
  <%- if properties.ha_proxy.tcp_backend_config -%>
    <%= format_indented_multiline_config(p("ha_proxy.tcp_backend_config")) %>
  <%- end -%>
    option httpchk GET /health
  <% tcp_router.instances.each_with_index do |instance, index| %>
    server node<%= index %> <%= instance.address %> check port 80 inter 1000
  <% end %>
<% end -%>

# TCP Backends
<%
tcp = p("ha_proxy.tcp")
if_link("tcp_backend") do |tcp_backend|
  tcp << {
    "name" => tcp_backend.instances.first.name || "link",
    "backend_servers" => tcp_backend.instances.map(&:address),
    "backend_servers_local" => tcp_backend.instances.select{ |n| n.az == spec.az }.map(&:address),
    "port" => tcp_backend.p("port", p("ha_proxy.tcp_link_port")),
    "backend_port" => tcp_backend.p("backend_port", p("ha_proxy.tcp_link_port")),
    "health_check_http" => tcp_backend.p("health_check_http", p("ha_proxy.tcp_link_health_check_http", nil))
  }
end -%>
<% tcp.each do |tcp_proxy| -%>
frontend tcp-frontend_<%= tcp_proxy["name"]%>
    mode tcp
  <%- if tcp_proxy["ssl"] -%>
    bind <%= p("ha_proxy.binding_ip") %>:<%= tcp_proxy["port"] %> <%= tcp_accept_proxy %> <%= tls_bind_options %> <%= v4v6 %>
  <%- else -%>
    bind <%= p("ha_proxy.binding_ip") %>:<%= tcp_proxy["port"] %> <%= tcp_accept_proxy %> <%= v4v6 %>
  <%- end -%>
    <%- if p("ha_proxy.expect_proxy_cidrs", []).size > 0 -%>
      tcp-request connection expect-proxy layer4 if { src -f /var/vcap/jobs/haproxy/config/expect_proxy_cidrs.txt }
    <%- end -%>
    default_backend tcp-<%= tcp_proxy["name"] %>

backend tcp-<%= tcp_proxy["name"] %>
    mode tcp
  <%- if properties.ha_proxy.tcp_backend_config -%>
    <%= format_indented_multiline_config(p("ha_proxy.tcp_backend_config")) %>
  <%- end -%>
  <%- if tcp_proxy["balance"] -%>
    balance <%= tcp_proxy["balance"] %>
  <%- end -%>
<%
  backend_port = tcp_proxy["port"]
  if tcp_proxy["backend_port"]
    backend_port = tcp_proxy["backend_port"]
  end
  backend_check_port = backend_port
  if_p("ha_proxy.tcp_link_check_port") do
    backend_check_port = p("ha_proxy.tcp_link_check_port")
  end
  resolvers = ""
  if_p("ha_proxy.resolvers") do
    resolvers = "resolvers default "
  end
  backend_ssl = ""

  if (tcp_proxy["backend_ssl"] || "").downcase != "verify"
    if tcp_proxy["backend_verifyhost"]
      abort "Conflicting configuration: backend_ssl must be 'verify' to use backend_verifyhost in tcp backend configuration"
    end
  end

  if tcp_proxy["backend_ssl"]
    if tcp_proxy["backend_ssl"].downcase == "verify"
      backend_ssl = "ssl verify required ca-file /var/vcap/jobs/haproxy/config/backend-ca-certs.pem "
      if tcp_proxy["backend_verifyhost"]
        backend_ssl += "verifyhost #{tcp_proxy["backend_verifyhost"]} "
      end
    elsif tcp_proxy["backend_ssl"].downcase == "noverify"
      backend_ssl = "ssl verify none "
    end
  end
-%>
  <% tcp_proxy["backend_servers"].each_with_index do |ip, index| %>
    server node<%= index %> <%= ip %>:<%= backend_port %> <%= resolvers -%>check port <%= backend_check_port -%> inter 1000 <%= backend_ssl %><%- if tcp_proxy["backend_servers_local"] && !tcp_proxy["backend_servers_local"].empty? && !tcp_proxy["backend_servers_local"].include?(ip)  -%> backup<%- end -%>
  <% end %>

  <%- if tcp_proxy["health_check_http"]  -%>
listen health_check_http_tcp-<%= tcp_proxy["name"] %>
    bind :<%= tcp_proxy["health_check_http"] %>
    mode http
    monitor-uri /health
    <%- if p("ha_proxy.accept_proxy") && !p("ha_proxy.disable_health_check_proxy") -%>
    tcp-request connection expect-proxy layer4 unless LOCALHOST
    <%- end -%>
    acl tcp-<%= tcp_proxy["name"] %>-routers_down nbsrv(tcp-<%= tcp_proxy["name"] %>) eq 0
    monitor fail if tcp-<%= tcp_proxy["name"] %>-routers_down

    <%- if p("ha_proxy.expect_proxy_cidrs", []).size > 0 -%>
listen health_check_http_tcp-<%= tcp_proxy["name"] %>_proxy_protocol
    bind :<%= tcp_proxy["health_check_http"] + 1 %> accept-proxy
    mode http
    monitor-uri /health
    acl tcp-<%= tcp_proxy["name"] %>-routers_down nbsrv(tcp-<%= tcp_proxy["name"] %>) eq 0
    monitor fail if tcp-<%= tcp_proxy["name"] %>-routers_down
    <%- end -%>
  <%- end -%>
<% end -%>

# }}}
<% end -%>
<%- end -%>
<%- if properties.ha_proxy.raw_blocks && !properties.ha_proxy.raw_blocks.empty? -%>
# raw blocks {{{
<%-
  correct_types_order = %w[global defaults listen frontend backend resolvers peers mailers]
  raw_blocks = p('ha_proxy.raw_blocks', {})
  ordered_blocks = correct_types_order.select { |type| raw_blocks.key?(type) }
  additional_types = raw_blocks.keys - correct_types_order
  all_found_types = ordered_blocks + additional_types
  all_found_types.each do |block_type|
    raw_block = raw_blocks[block_type]
    if raw_block.is_a?(Hash)
      raw_block.each do |block_id, block_raw_config|
%>
<%= block_type %> <%= block_id %>
    <%= format_indented_multiline_config(block_raw_config) %>
<%-
      end
    else
%>
<%= block_type %>
    <%= format_indented_multiline_config(raw_block) %>
<%-
    end
  end
%>
# }}}
<%- end -%>
